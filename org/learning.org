#+TITLE: Learning

* Introduction

This project is an experiment.  I'd like to add a bit more structure
to the things I know and the things I'm interested in learning about.
Maybe a notebook would be better; maybe not.

I'm not sure how I'm going to incorporate images and diagrams into
this notebook (to make it a more visual experience) but we'll see how
far I can get.

* Topics

** Artificial Intelligence

*** Reinforcement Learning

**** Terms

- reward :: what the agent expects to receive in the short term for
            taking a particular action.  May be negative (punishment)
            or positive (actual reward).

- value :: what the agent expects to receive in the long term by
           executing its policy.

*** Neural Networks

*** Bayesian Networks

*** Books
**** "Artificial Intelligence, A Modern Approach" by Norvig, et al.
** Big Data
*** Hadoop
*** Cascading
** Cognitive Science

*** Books

**** "Brain Rules" by John Medina

** Computer Architecture
*** Memory Hierarchy
**** Registers
**** L1 Cache
**** L2 Cache
**** L3 Cache
**** Main Memory
**** Disk
**** Network
**** NUMA
**** MESI Protocol
**** Interconnect
**** Load/Store Buffers
**** Write Absorbtion
*** Central Processing Unit
*** Networking
*** CUDA
*** Storage Drives
**** SSD
**** Hard Drive (Rotating)
** Databases

*** Relational

**** MySQL
**** PostgreSQL

*** NoSQL

**** Cassandra


***** Drivers

****** Java

******* [[https://github.com/datastax/java-driver][Official DataStax CQL Driver]]

- [[http://www.datastax.com/documentation/developer/java-driver/1.0/webhelp/index.html][Documentation]]
- [[http://www.datastax.com/drivers/java/apidocs/][API]]

**** MongoDB

** Data Structures
*** Analysis
**** Big O
**** Analytic Combinatorics
** Distributed Systems
*** Akka
*** Consensus
*** Vector Clocks
** Denotational Semantics

** Emacs
*** Elisp
*** Packages
**** Org-Mode
**** Magit
**** Haskell-Mode
**** Yasnippet
**** ido
*** Tips & Tricks
** Emotionally Focused Therapy

*** Links 

- [[https://en.wikipedia.org/wiki/Emotionally_focused_therapy][on Wikipedia]]

** Fault Tolerance
*** Terms

- failure :: When the delivered service no longer complies with the specification.  If there is no specification, there can be no failure. Failures are observed by the user of the system.  Failures are caused by errors.

- error :: An incorrect system behavior that may cause a failure. Errors fall into two categories: timing and value.  Value errors can take the form of incorrect state or an incorrect discrete value. Errors can be detected before they cause failures.  Errors are the manifestation of faults.  The presence of errors implies the presence of faults.

- fault :: a defect in a system that can cause an error.  Faults can be caused by incorrect requirements, coding defects, incorrect designs, etc.  A fault that is not causing any errors is latent.

- latent :: A fault that is not causing any errors is latent.

- active :: A fault that causes an error is active.

- fail-silent :: a system that presents the correct result or no result at all.

- crash-failure :: the system stops after it detects an error

*** Bad Assumptions

- Only one error occurs at a time
- One error is recovered from  before the next one occurs
- Each error is independent from each other error

*** Fault -> Error -> Failure

*** Books
**** [[http://techbus.safaribooksonline.com/book/software-engineering-and-development/patterns/9780470319796][Patterns for Fault Tolerant Software]] by Robert S. Hanmer
** Functional Programming 
*** Lambda Calculus

*** Functional Data Structures
** Information Theory
   
*** Entropy
*** Compression
** Learning

** Machine Learning

*** Links

- [ ] [[http://www.kaggle.com/][Kaggle]]

*** Supervised Learning


**** Decision Trees

**** Naive Bayesian Classifier

*** Unsupervised Learning


**** Clustering

*** Ensemble Methods
*** Boosting
*** Tools

**** Weka

***** Links
 
- [[http://www.cs.waikato.ac.nz/ml/weka/][Home Page]]

** Mathematics
*** Algebra
*** Linear Algebra
*** Discrete Math
*** Abstract Algebra
*** Probability
*** Statistics
*** Distance Metrics
*** Graph Theory
*** Proofs

** Operating Systems
*** Concepts
**** Virtual Memory
**** Devices
**** Networking
**** Security
**** Troubleshooting
**** Optimizing
*** Linux

*** FreeBSD
    
** Programming Environments

*** Java Virtual Machine

*** .NET Runtime

I'm pretty much focusing on the JVM for now.

** Programming Languages

*** Java

**** Features

***** NIO
      
***** Lambdas

***** Concurrency

*** Scala

**** Macros

**** Akka

**** scalaz

*** Haskell

**** Links

- [[http://www.haskell.org/haskellwiki/Haskell][Haskell Home Page]]
- [[http://book.realworldhaskell.org/read/][Real World Haskell]]
- [[http://learnyouahaskell.com/chapters][Learn You a Haskell]]
- [[http://www.haskell.org/ghc/docs/latest/html/libraries/index.html][Libraries Documentation]]
- [[http://themonadreader.wordpress.com/][The Monad.Reader]]
- [[http://planet.haskell.org/][Planet Haskell]]

**** To Read [0%] [0/14]

- [ ] [[../res/yaht.pdf][Yet Another Haskell Tutorial]]
- [ ] [[../res/HR.pdf][Haskell Road to Logic Math and Programming]]
- [ ] [[http://en.wikibooks.org/wiki/Haskell][Haskell Wiki Book]] ([[../res/HaskellWikibook.pdf][PDF]])
- [ ] [[http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell][Hitchhiker's Guide to Haskell]]
- [ ] [[../res/awkward-squad.pdf][Tackling the Awkward Squad]]
- [ ] [[http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours][Write Yourself a Scheme in 48 Hours]]
- [ ] [[http://www.haskell.org/haskellwiki/Scrap_your_boilerplate][Scrap Your Boilerplate]]
- [ ] [[../res/HPR.pdf][Higher-order + Polymorphic = Reuse]]
- [ ] [[../res/whyfp.pdf][Why Functional Programming]]
- [ ] [[../res/monads2arrows.pdf][Generalizing Monads to Arrows]]
- [ ] [[../res/arrows_robots.pdf][Arrows, Robots, and FRP]]
- [ ] [[../res/edsl.pdf][Building Domain-Specific Embedded Languages]]
- [ ] [[../res/monad_interpreter.pdf][Build a Monadic Interpreter]]
- [ ] [[http://www.haskell.org/haskellwiki/Category:Style][Haskell Style Wiki Category]]
- [ ] [[http://www.haskell.org/haskellwiki/Emacs][Emacs & Haskell]]
- [ ] [[http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program][How to Write a Haskell Program]]
- [ ] [[http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html][GHC/GHCI Manual]]
- [ ] [[http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls][Functional Pearls]]
- [ ] [[http://www.haskell.org/haskellwiki/Research_papers/Data_structures][Research Papers on Data Structures]]
- [ ] [[http://www.haskell.org/haskellwiki/Research_papers/Top_10][Top Research Papers]]
- [ ] [[http://www.scs.stanford.edu/11au-cs240h/notes/][Lecture Notes from Stanford's Haskell Course]]
  
*** C++

**** Lambda Expressions

**** Concurrency

*** Python

**** Idioms

**** Pandas

**** IPython

**** SciKit-Learn
     
*** Other
**** Prolog

**** ML
**** Javascript
** Software Architecture
** Ultra Learning

*** Links [66%] [2/3]

**** TODO [[../res/scott_young.pdf][Scott's Book on Learning]]

**** DONE [[http://www.scotthyoung.com/blog/2011/09/01/learn-faster/][The Feynman Technique]]

**** DONE [[http://calnewport.com/blog/2012/10/26/mastering-linear-algebra-in-10-days-astounding-experiments-in-ultra-learning/][Interview with Scott Young]]

The method you use to learn matters lot.  Deeper levels of processing
can double your efficiency.

Cramming does not work at MIT; courses build on each other.

Deepening Understanding is made up of two things:

- Making Connections - connections provide context
- Debugging Errors - make sure your understanding of a concept is
  complete and correct.  As you debug, you're reviewing and
  reinforcing the learning.

***** Drill down Method

****** Coverage

Get a map of the terrain.  Get a general sense of what you need to
learn.  This could mean watching lecture videos or reading textbooks.
How about the syllabus?  This is the least efficient stage.  Watch
videos at 1.5X or 2X speed.

Don't highlight books.  Instead take sparse notes while reading or do
a one paragraph summary after each major section.

****** Practice 

Practice problems are huge for boosting your understanding but there
are two efficiency traps if you're not careful.

- Not getting immediate feedback.  If you want to learn you need
  immediate feedback.  The best way is to go question by question with
  the answers in hand.  Finish a question and then check your answer.

- Grinding Problems - Practice problems should be used to highlight
  areas where you need to gain more understanding in.  See Feynman
  Technique in a bit.

So Scott is saying use Practice Problems but don't get bogged down in
them.  If you get stuck, brush up on the area where you got stuck.

****** Insight

The goal of coverage and practice questions is to get you to the point
where you know what you don't understand.  The Feynman Technique helps
you fill in the gaps in your knowledge.

***** The Feynman Technique

Richard Feynman describes himself struggling with a hard research
paper. His solution was to go meticulously through the supporting
material until he understood everything that was required to
understand the hard idea.

In other words, divide and conquer.  Digest the big idea that you
don't understand into little chunks that you can learn and understand
and then work your way back up to the big idea.

Steps:

- Get a piece of paper
- Write at the top the idea or process you want to understand.
- Explain the idea as if you were teaching it to someone else.

During step 3 youll get to a place where you can't explain something.
That's the precise gap in your understanding tha tyou need to fill.
Research the answer.  By narrowly defining your misunderstanding it
becomes easier to find the precise answer.

If you don't get the idea at all, copy the author's explanation but
try to elaborate and clarify it yourself.

For procedures explain each step, not only what it does but how to
execute it, and perhaps why.

For formulas, you should seek to understand them not just memorize
them.  If you see a formula you don't understand, break it down into
parts and try to understand the parts.

***** Developing Deeper Intuition

Most intuitions are one of the following types:

- Analogies - You notice a similarity between one thing and another
  (easier to understand) idea.
- Visulizations - making a mental picture of an abstract idea (even if its
  incomplete) helps.
- Simplifications - If you can explain something to your grandmother,
  you really understand it.  Simplification is the strengthening of
  connections between basic components and complex ideas.

Once you feel you understand a concept see if you can use one of the
above methods above to explain it.

** Version Control

*** git

** Web Frameworks
*** Client Side
**** Angular JS
*** Server Side
**** Play!

** Systems
*** Links
**** TODO [[https://en.wikipedia.org/wiki/Systems_thinking][Systems Thinking (Wikipedia)]]
** Simulations  



#+OPTIONS: num:nil
