#+TITLE: Learning

* Introduction

This project is an experiment.  I'd like to add a bit more structure
to the things I know and the things I'm interested in learning about.
Maybe a notebook would be better; maybe not.

I'm not sure how I'm going to incorporate images and diagrams into
this notebook (to make it a more visual experience) but we'll see how
far I can get.

* Topics

** Artificial Intelligence

*** Reinforcement Learning

**** Terms

- reward :: what the agent expects to receive in the short term for
            taking a particular action.  May be negative (punishment)
            or positive (actual reward).

- value :: what the agent expects to receive in the long term by
           executing its policy.

*** Neural Networks

*** Bayesian Networks

** Cognitive Science

*** Books

**** "Brain Rules" by John Medina

** Databases

*** Relational

*** NoSQL

**** Cassandra

** Denotational Semantics

** Emacs
** Emotionally Focused Therapy

*** Links 

- [[https://en.wikipedia.org/wiki/Emotionally_focused_therapy][on Wikipedia]]

** Functional Programming 

*** Lambda Calculus

** Information Theory

** Machine Learning

*** Links

- [ ] [[http://www.kaggle.com/][Kaggle]]

*** Supervised Learning


**** Decision Trees

**** Naive Bayesian Classifier

*** Unsupervised Learning


**** Clustering

*** Tools

**** Weka

***** Links
 
- [[http://www.cs.waikato.ac.nz/ml/weka/][Home Page]]

** Mathematics

*** Linear Algebra
*** Discrete Math
*** Abstract Algebra
*** Probability
*** Statistics
*** Distance Metrics
*** Graph Theory

** Operating Systems

*** Linux

*** FreeBSD
    
** Programming Environment

*** Java Virtual Machine

** Programming Languages

*** Java

**** Features

***** NIO
      
***** Lambdas

***** Concurrency

*** Scala

**** Macros

**** Akka

**** scalaz

*** Haskell

**** Links

- [[http://www.haskell.org/haskellwiki/Haskell][Haskell Home Page]]
- [[http://book.realworldhaskell.org/read/][Real World Haskell]]
- [[http://learnyouahaskell.com/chapters][Learn You a Haskell]]
- [[http://www.haskell.org/ghc/docs/latest/html/libraries/index.html][Libraries Documentation]]
- [[http://themonadreader.wordpress.com/][The Monad.Reader]]
- [[http://planet.haskell.org/][Planet Haskell]]

**** To Read [0%] [0/14]

- [ ] [[../res/yaht.pdf][Yet Another Haskell Tutorial]]
- [ ] [[../res/HR.pdf][Haskell Road to Logic Math and Programming]]
- [ ] [[http://en.wikibooks.org/wiki/Haskell][Haskell Wiki Book]] ([[../res/HaskellWikibook.pdf][PDF]])
- [ ] [[http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell][Hitchhiker's Guide to Haskell]]
- [ ] [[../res/awkward-squad.pdf][Tackling the Awkward Squad]]
- [ ] [[http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours][Write Yourself a Scheme in 48 Hours]]
- [ ] [[http://www.haskell.org/haskellwiki/Scrap_your_boilerplate][Scrap Your Boilerplate]]
- [ ] [[../res/HPR.pdf][Higher-order + Polymorphic = Reuse]]
- [ ] [[../res/whyfp.pdf][Why Functional Programming]]
- [ ] [[../res/monads2arrows.pdf][Generalizing Monads to Arrows]]
- [ ] [[../res/arrows_robots.pdf][Arrows, Robots, and FRP]]
- [ ] [[../res/edsl.pdf][Building Domain-Specific Embedded Languages]]
- [ ] [[../res/monad_interpreter.pdf][Build a Monadic Interpreter]]
- [ ] [[http://www.haskell.org/haskellwiki/Category:Style][Haskell Style Wiki Category]]
- [ ] [[http://www.haskell.org/haskellwiki/Emacs][Emacs & Haskell]]
- [ ] [[http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program][How to Write a Haskell Program]]
- [ ] [[http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html][GHC/GHCI Manual]]
- [ ] [[http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls][Functional Pearls]]
- [ ] [[http://www.haskell.org/haskellwiki/Research_papers/Data_structures][Research Papers on Data Structures]]
- [ ] [[http://www.haskell.org/haskellwiki/Research_papers/Top_10][Top Research Papers]]
- [ ] [[http://www.scs.stanford.edu/11au-cs240h/notes/][Lecture Notes from Stanford's Haskell Course]]
  
*** C++

**** Lambda Expressions

**** Concurrency

*** Python

**** Idioms

**** Pandas

**** IPython

**** SciKit-Learn

** Ultra Learning

*** Links [0%] [0/1]

**** TODO [[http://calnewport.com/blog/2012/10/26/mastering-linear-algebra-in-10-days-astounding-experiments-in-ultra-learning/][Interview with Scott Young]]

The method you use to learn matters lot.  Deeper levels of processing
can double your efficiency.

Cramming does not work at MIT; courses build on each other.

Deepening Understanding is made up of two things:

- Making Connections - connections provide context
- Debugging Errors - make sure your understanding of a concept is
  complete and correct.  As you debug, you're reviewing and
  reinforcing the learning.

***** Drill down Method

****** Coverage

Get a map of the terrain.  Get a general sense of what you need to
learn.  This could mean watching lecture videos or reading textbooks.
How about the syllabus?  This is the least efficient stage.  Watch
videos at 1.5X or 2X speed.

Don't highlight books.  Instead take sparse notes while reading or do
a one paragraph summary after each major section.

****** Practice 

Practice problems are huge for boosting your understanding but there
are two efficiency traps if you're not careful.

- Not getting immediate feedback.  If you want to learn you need
  immediate feedback.  The best way is to go question by question with
  the answers in hand.  Finish a question and then check your answer.

- Grinding Problems - Practice problems should be used to highlight
  areas where you need to gain more understanding in.  See Feynman
  Technique in a bit.

So Scott is saying use Practice Problems but don't get bogged down in
them.  If you get stuck, brush up on the area where you got stuck.

****** Insight

The goal of coverage and practice questions is to get you to the point
where you know what you don't understand.  The Feynman Technique helps
you fill in the gaps in your knowledge.

***** The Feynman Technique

Richard Feynman describes himself struggling with a hard research
paper. His solution was to go meticulously through the supporting
material until he understood everything that was required to
understand the hard idea.

In other words, divide and conquer.  Digest the big idea that you
don't understand into little chunks that you can learn and understand
and then work your way back up to the big idea.

Steps:

- Get a piece of paper
- Write at the top the idea or process you want to understand.
- Explain the idea as if you were teaching it to someone else.

During step 3 youll get to a place where you can't explain something.
That's the precise gap in your understanding tha tyou need to fill.
Research the answer.  By narrowly defining your misunderstanding it
becomes easier to find the precise answer.

If you don't get the idea at all, copy the author's explanation but
try to elaborate and clarify it yourself.

For procedures explain each step, not only what it does but how to
execute it, and perhaps why.

For formulas, you should seek to understand them not just memorize
them.  If you see a formula you don't understand, break it down into
parts and try to understand the parts.

** Version Control

*** git

** Web Frameworks

*** Play!
  
#+OPTIONS: toc:nil num:nil
